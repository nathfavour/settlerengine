# SettlerEngine Architecture> **Status:** Draft / Active Development  > **Pattern:** Hexagonal (Ports & Adapters)  > **Language:** Go (Golang)## 1. Architectural OverviewSettlerEngine is designed as a protocol-agnostic settlement layer for the next generation of commerceserving both human users and autonomous AI agents. Unlike monolithic legacy solutions (e.g., BTCPayServer), SettlerEngine strictly adheres to **Hexagonal Architecture**. This decouples our **Domain Core** (business rules) from the "dirty" details of external infrastructure (blockchains, databases, HTTP protocols), allowing us to swap or upgrade infrastructure without touching business logic.### High-Level Diagram```mermaidgraph TD    subgraph "External World (Driving)"        User[User / Merchant]        Agent[AI Agent (x402/L402)]    end    subgraph "SettlerEngine (Hexagon)"        subgraph "Driving Adapters"            API[REST / gRPC API]            EventSub[Event Subscriber]        end        subgraph "Domain Core"            Logic[Invoice Aggregate & State Machine]            Services[Payment Normalization Service]        end        subgraph "Driven Adapters"            DB_Adapter[PostgreSQL Adapter]            Chain_Adapter[Blockchain Adapter (BTC/SOL)]            Msg_Adapter[Watermill Pub/Sub]        end    end    subgraph "Infrastructure (Driven)"        DB[(PostgreSQL)]        BTC[Bitcoin Node]        SOL[Solana RPC]        Queue[Message Broker]    end    User --> API    Agent --> API    API --> Logic    Logic --> DB_Adapter    Logic --> Chain_Adapter    Logic --> Msg_Adapter    DB_Adapter --> DB    Chain_Adapter --> BTC    Chain_Adapter --> SOL    Msg_Adapter --> Queue2. Core Components2.1 The Domain CoreThe heart of the application. It contains pure Go code with zero dependencies on frameworks, databases, or external APIs. * Invoice Aggregate: A state machine managing the lifecycle of a payment (New -> Detect -> Confirm -> Settle). * Money Value Object: Handles precision arithmetic to prevent floating-point errors common in crypto. * PaymentSignal: A normalized structure that translates distinct blockchain events into a generic internal language.2.2 Ports (Interfaces)Ports define the contract between the Domain and the outside world. * Driving Ports (Inbound): Define how the engine can be used.   * PaymentInitiator: Methods for creating invoices and refund requests. * Driven Ports (Outbound): Define what the engine needs from infrastructure.   * InvoiceRepository: Interface for persistence.   * BlockchainClient: Interface for watching addresses and broadcasting transactions.2.3 Adapters (Implementations)The concrete implementations of our Ports. * Primary Adapters: HTTP Handlers (Gin/Fiber), gRPC Servers. * Secondary Adapters:   * Persistence: PostgreSQL (via pgx or sqlc).   * Blockchain: RPC wrappers for Bitcoin Core and Solana.3. Key Technical Strategies3.1 Multi-Chain Nexus (Payment Abstraction)To support both UTXO (Bitcoin/Litecoin) and Account-based (Solana/USDT) models simultaneously: * We utilize a Payment Abstraction Layer. * All incoming chain activity is normalized into a standard PaymentSignal struct within the adapter layer before reaching the Domain. * This allows the Domain to treat a Lightning Network generic settlement identically to a Solana SPL Token transfer.3.2 Agent Economy & Programmatic PaymentsSettlerEngine is "Agent-First," supporting machine-to-machine value transfer protocols natively: * x402: Standard implementation of HTTP 402 "Payment Required" for on-chain resource gating. * L402 (LSAT): Leverages Bitcoin Lightning and Macaroons for high-frequency micropayments. This enables stateless verification of payment (authentication + payment in a single token).3.3 Event-Driven Architecture (EDA) & SourcingWe reject resource-intensive polling in favor of a reactive system using the Watermill library. * Event Sourcing: The ledger is an append-only log of immutable events. This guarantees perfect auditability and allows us to replay history to rebuild state. * Saga Pattern: Used for distributed transactions (e.g., Settlement Sagas) where actions across multiple chains or services must either all succeed or perform compensating transactions.3.4 CQRS (Command Query Responsibility Segregation) * Write Model: Optimized for consistency and business logic validation. * Read Model: Optimized for high-performance querying (e.g., specific projections for Merchant Dashboards).4. Security ArchitectureWe employ a Hot/Warm/Cold tiered wallet system to minimize attack surface.| Tier | Component | Key Type | Function ||---|---|---|---|| Hot | API Server | xpub / zpub | Receive Only. Can generate addresses but cannot sign transactions. || Warm | Signing Service | Private Keys (Sharded) | Automated low-value settlements. || Cold | Offline Storage | Hardware Wallets | Long-term storage. Requires manual PSBT signing. | * Automated Treasury Intelligence: Algorithms (like CPPI) monitor hot wallet balances and trigger auto-sweeps or rebalancing. * PSBT Support: All Bitcoin flows support Partially Signed Bitcoin Transactions for multi-sig workflows. Development Guidelines * Idempotency: All API endpoints and Event Handlers must be idempotent. * Concurrency: Leverage Go's goroutines and context propagation for all I/O bound operations. * Testing:   * Unit Tests: Must target the Domain Core (mocking all Ports).   * Integration Tests: Must target Adapters (using TestContainers for DB/Chain nodes).<!-- end list -->